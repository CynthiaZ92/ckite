/**
 * Generated by Scrooge
 *   version: ?
 *   rev: ?
 *   built at: ?
 */
package the.walrus.ckite.rpc.thrift

import com.twitter.scrooge.{
  ThriftService, ThriftStruct, ThriftStructCodec, ThriftStructCodec3}
import java.nio.ByteBuffer
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"), date = "2013-10-15T00:11:30.751-0300")
trait CKiteService[+MM[_]] extends ThriftService {
  
  def sendRequestVote(requestVote: RequestVoteST): MM[RequestVoteResponseST]
  
  def sendAppendEntries(appendEntries: AppendEntriesST): MM[AppendEntriesResponseST]
}


object CKiteService {
  
  object sendRequestVote$args extends ThriftStructCodec3[sendRequestVote$args] {
    val Struct = new TStruct("sendRequestVote_args")
    val RequestVoteField = new TField("requestVote", TType.STRUCT, 1)
    val RequestVoteFieldManifest = implicitly[Manifest[RequestVoteST]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendRequestVote$args) {
    }
  
    override def encode(_item: sendRequestVote$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): sendRequestVote$args = Immutable.decode(_iprot)
  
    def apply(
      requestVote: RequestVoteST
    ): sendRequestVote$args = new Immutable(
      requestVote
    )
  
    def unapply(_item: sendRequestVote$args): Option[RequestVoteST] = Some(_item.requestVote)
  
    object Immutable extends ThriftStructCodec3[sendRequestVote$args] {
      override def encode(_item: sendRequestVote$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): sendRequestVote$args = {
        var requestVote: RequestVoteST = null
        var _got_requestVote = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* requestVote */
                _field.`type` match {
                  case TType.STRUCT => {
                    requestVote = {
                      RequestVoteST.decode(_iprot)
                    }
                    _got_requestVote = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          requestVote
        )
      }
    }
  
    /**
     * The default read-only implementation of sendRequestVote$args.  You typically should not need to
     * directly reference this class; instead, use the sendRequestVote$args.apply method to construct
     * new instances.
     */
    class Immutable(
      val requestVote: RequestVoteST
    ) extends sendRequestVote$args
  
  }
  
  trait sendRequestVote$args extends ThriftStruct
    with Product1[RequestVoteST]
    with java.io.Serializable
  {
    import sendRequestVote$args._
  
  
    def requestVote: RequestVoteST
  
    def _1 = requestVote
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): sendRequestVote$args =
      _fieldId match {
        case 1 => copy(requestVote = null)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      sendRequestVote$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (requestVote ne null) {
        val requestVote_item = requestVote
        _oprot.writeFieldBegin(RequestVoteField)
        requestVote_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      requestVote: RequestVoteST = this.requestVote
    ): sendRequestVote$args =
      new Immutable(
        requestVote
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendRequestVote$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => requestVote
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendRequestVote$args"
  }
  
  object sendRequestVote$result extends ThriftStructCodec3[sendRequestVote$result] {
    val Struct = new TStruct("sendRequestVote_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[RequestVoteResponseST]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendRequestVote$result) {
    }
  
    override def encode(_item: sendRequestVote$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): sendRequestVote$result = Immutable.decode(_iprot)
  
    def apply(
      success: Option[RequestVoteResponseST] = None
    ): sendRequestVote$result = new Immutable(
      success
    )
  
    def unapply(_item: sendRequestVote$result): Option[Option[RequestVoteResponseST]] = Some(_item.success)
  
    object Immutable extends ThriftStructCodec3[sendRequestVote$result] {
      override def encode(_item: sendRequestVote$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): sendRequestVote$result = {
        var success: RequestVoteResponseST = null
        var _got_success = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      RequestVoteResponseST.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of sendRequestVote$result.  You typically should not need to
     * directly reference this class; instead, use the sendRequestVote$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[RequestVoteResponseST] = None
    ) extends sendRequestVote$result
  
  }
  
  trait sendRequestVote$result extends ThriftStruct
    with Product1[Option[RequestVoteResponseST]]
    with java.io.Serializable
  {
    import sendRequestVote$result._
  
  
    def success: Option[RequestVoteResponseST]
  
    def _1 = success
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): sendRequestVote$result =
      _fieldId match {
        case 0 => copy(success = None)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      sendRequestVote$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[RequestVoteResponseST] = this.success
    ): sendRequestVote$result =
      new Immutable(
        success
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendRequestVote$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendRequestVote$result"
  }
  
  object sendAppendEntries$args extends ThriftStructCodec3[sendAppendEntries$args] {
    val Struct = new TStruct("sendAppendEntries_args")
    val AppendEntriesField = new TField("appendEntries", TType.STRUCT, 1)
    val AppendEntriesFieldManifest = implicitly[Manifest[AppendEntriesST]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendAppendEntries$args) {
    }
  
    override def encode(_item: sendAppendEntries$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): sendAppendEntries$args = Immutable.decode(_iprot)
  
    def apply(
      appendEntries: AppendEntriesST
    ): sendAppendEntries$args = new Immutable(
      appendEntries
    )
  
    def unapply(_item: sendAppendEntries$args): Option[AppendEntriesST] = Some(_item.appendEntries)
  
    object Immutable extends ThriftStructCodec3[sendAppendEntries$args] {
      override def encode(_item: sendAppendEntries$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): sendAppendEntries$args = {
        var appendEntries: AppendEntriesST = null
        var _got_appendEntries = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* appendEntries */
                _field.`type` match {
                  case TType.STRUCT => {
                    appendEntries = {
                      AppendEntriesST.decode(_iprot)
                    }
                    _got_appendEntries = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          appendEntries
        )
      }
    }
  
    /**
     * The default read-only implementation of sendAppendEntries$args.  You typically should not need to
     * directly reference this class; instead, use the sendAppendEntries$args.apply method to construct
     * new instances.
     */
    class Immutable(
      val appendEntries: AppendEntriesST
    ) extends sendAppendEntries$args
  
  }
  
  trait sendAppendEntries$args extends ThriftStruct
    with Product1[AppendEntriesST]
    with java.io.Serializable
  {
    import sendAppendEntries$args._
  
  
    def appendEntries: AppendEntriesST
  
    def _1 = appendEntries
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): sendAppendEntries$args =
      _fieldId match {
        case 1 => copy(appendEntries = null)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      sendAppendEntries$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (appendEntries ne null) {
        val appendEntries_item = appendEntries
        _oprot.writeFieldBegin(AppendEntriesField)
        appendEntries_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      appendEntries: AppendEntriesST = this.appendEntries
    ): sendAppendEntries$args =
      new Immutable(
        appendEntries
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendAppendEntries$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => appendEntries
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendAppendEntries$args"
  }
  
  object sendAppendEntries$result extends ThriftStructCodec3[sendAppendEntries$result] {
    val Struct = new TStruct("sendAppendEntries_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[AppendEntriesResponseST]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendAppendEntries$result) {
    }
  
    override def encode(_item: sendAppendEntries$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): sendAppendEntries$result = Immutable.decode(_iprot)
  
    def apply(
      success: Option[AppendEntriesResponseST] = None
    ): sendAppendEntries$result = new Immutable(
      success
    )
  
    def unapply(_item: sendAppendEntries$result): Option[Option[AppendEntriesResponseST]] = Some(_item.success)
  
    object Immutable extends ThriftStructCodec3[sendAppendEntries$result] {
      override def encode(_item: sendAppendEntries$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): sendAppendEntries$result = {
        var success: AppendEntriesResponseST = null
        var _got_success = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      AppendEntriesResponseST.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of sendAppendEntries$result.  You typically should not need to
     * directly reference this class; instead, use the sendAppendEntries$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[AppendEntriesResponseST] = None
    ) extends sendAppendEntries$result
  
  }
  
  trait sendAppendEntries$result extends ThriftStruct
    with Product1[Option[AppendEntriesResponseST]]
    with java.io.Serializable
  {
    import sendAppendEntries$result._
  
  
    def success: Option[AppendEntriesResponseST]
  
    def _1 = success
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): sendAppendEntries$result =
      _fieldId match {
        case 0 => copy(success = None)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      sendAppendEntries$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[AppendEntriesResponseST] = this.success
    ): sendAppendEntries$result =
      new Immutable(
        success
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendAppendEntries$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendAppendEntries$result"
  }

  import com.twitter.util.Future

  @deprecated("use CKiteService[Future]", "3.4.0")
  trait FutureIface extends  CKiteService[Future] {
    
    def sendRequestVote(requestVote: RequestVoteST): Future[RequestVoteResponseST]
    
    def sendAppendEntries(appendEntries: AppendEntriesST): Future[AppendEntriesResponseST]
  }

  @deprecated("use CKiteService$FinagleClient", "3.4.0")
  class FinagledClient(
      service: com.twitter.finagle.Service[com.twitter.finagle.thrift.ThriftClientRequest, Array[Byte]],
      protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
      serviceName: String = "",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver)
    extends CKiteService$FinagleClient(
      service,
      protocolFactory,
      serviceName,
      stats)
    with FutureIface

  @deprecated("use CKiteService$FinagleService", "3.4.0")
  class FinagledService(
      iface: FutureIface,
      protocolFactory: TProtocolFactory)
    extends CKiteService$FinagleService(
      iface,
      protocolFactory)
}
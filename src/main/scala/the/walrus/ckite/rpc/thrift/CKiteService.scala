/**
 * Generated by Scrooge
 *   version: ?
 *   rev: ?
 *   built at: ?
 */
package the.walrus.ckite.rpc.thrift

import com.twitter.scrooge.{
  ThriftService, ThriftStruct, ThriftStructCodec, ThriftStructCodec3}
import java.nio.ByteBuffer
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"), date = "2014-02-08T02:35:28.747-0300")
trait CKiteService[+MM[_]] extends ThriftService {
  
  def sendRequestVote(requestVote: RequestVoteST): MM[RequestVoteResponseST]
  
  def sendAppendEntries(appendEntries: AppendEntriesST): MM[AppendEntriesResponseST]
  
  def forwardCommand(command: ByteBuffer): MM[ByteBuffer]
  
  def installSnapshot(installSnapshot: InstallSnapshotST): MM[Boolean]
  
  def join(memberId: JoinRequestST): MM[JoinResponseST]
  
  def getMembers(): MM[GetMembersResponseST]
}


object CKiteService {
  
  object sendRequestVote$args extends ThriftStructCodec3[sendRequestVote$args] {
    val Struct = new TStruct("sendRequestVote_args")
    val RequestVoteField = new TField("requestVote", TType.STRUCT, 1)
    val RequestVoteFieldManifest = implicitly[Manifest[RequestVoteST]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendRequestVote$args) {
    }
  
    override def encode(_item: sendRequestVote$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): sendRequestVote$args = Immutable.decode(_iprot)
  
    def apply(
      requestVote: RequestVoteST
    ): sendRequestVote$args = new Immutable(
      requestVote
    )
  
    def unapply(_item: sendRequestVote$args): Option[RequestVoteST] = Some(_item.requestVote)
  
    object Immutable extends ThriftStructCodec3[sendRequestVote$args] {
      override def encode(_item: sendRequestVote$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): sendRequestVote$args = {
        var requestVote: RequestVoteST = null
        var _got_requestVote = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* requestVote */
                _field.`type` match {
                  case TType.STRUCT => {
                    requestVote = {
                      RequestVoteST.decode(_iprot)
                    }
                    _got_requestVote = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          requestVote
        )
      }
    }
  
    /**
     * The default read-only implementation of sendRequestVote$args.  You typically should not need to
     * directly reference this class; instead, use the sendRequestVote$args.apply method to construct
     * new instances.
     */
    class Immutable(
      val requestVote: RequestVoteST
    ) extends sendRequestVote$args
  
  }
  
  trait sendRequestVote$args extends ThriftStruct
    with Product1[RequestVoteST]
    with java.io.Serializable
  {
    import sendRequestVote$args._
  
  
    def requestVote: RequestVoteST
  
    def _1 = requestVote
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): sendRequestVote$args =
      _fieldId match {
        case 1 => copy(requestVote = null)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      sendRequestVote$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (requestVote ne null) {
        val requestVote_item = requestVote
        _oprot.writeFieldBegin(RequestVoteField)
        requestVote_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      requestVote: RequestVoteST = this.requestVote
    ): sendRequestVote$args =
      new Immutable(
        requestVote
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendRequestVote$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => requestVote
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendRequestVote$args"
  }
  
  object sendRequestVote$result extends ThriftStructCodec3[sendRequestVote$result] {
    val Struct = new TStruct("sendRequestVote_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[RequestVoteResponseST]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendRequestVote$result) {
    }
  
    override def encode(_item: sendRequestVote$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): sendRequestVote$result = Immutable.decode(_iprot)
  
    def apply(
      success: Option[RequestVoteResponseST] = None
    ): sendRequestVote$result = new Immutable(
      success
    )
  
    def unapply(_item: sendRequestVote$result): Option[Option[RequestVoteResponseST]] = Some(_item.success)
  
    object Immutable extends ThriftStructCodec3[sendRequestVote$result] {
      override def encode(_item: sendRequestVote$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): sendRequestVote$result = {
        var success: RequestVoteResponseST = null
        var _got_success = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      RequestVoteResponseST.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of sendRequestVote$result.  You typically should not need to
     * directly reference this class; instead, use the sendRequestVote$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[RequestVoteResponseST] = None
    ) extends sendRequestVote$result
  
  }
  
  trait sendRequestVote$result extends ThriftStruct
    with Product1[Option[RequestVoteResponseST]]
    with java.io.Serializable
  {
    import sendRequestVote$result._
  
  
    def success: Option[RequestVoteResponseST]
  
    def _1 = success
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): sendRequestVote$result =
      _fieldId match {
        case 0 => copy(success = None)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      sendRequestVote$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[RequestVoteResponseST] = this.success
    ): sendRequestVote$result =
      new Immutable(
        success
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendRequestVote$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendRequestVote$result"
  }
  
  object sendAppendEntries$args extends ThriftStructCodec3[sendAppendEntries$args] {
    val Struct = new TStruct("sendAppendEntries_args")
    val AppendEntriesField = new TField("appendEntries", TType.STRUCT, 1)
    val AppendEntriesFieldManifest = implicitly[Manifest[AppendEntriesST]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendAppendEntries$args) {
    }
  
    override def encode(_item: sendAppendEntries$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): sendAppendEntries$args = Immutable.decode(_iprot)
  
    def apply(
      appendEntries: AppendEntriesST
    ): sendAppendEntries$args = new Immutable(
      appendEntries
    )
  
    def unapply(_item: sendAppendEntries$args): Option[AppendEntriesST] = Some(_item.appendEntries)
  
    object Immutable extends ThriftStructCodec3[sendAppendEntries$args] {
      override def encode(_item: sendAppendEntries$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): sendAppendEntries$args = {
        var appendEntries: AppendEntriesST = null
        var _got_appendEntries = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* appendEntries */
                _field.`type` match {
                  case TType.STRUCT => {
                    appendEntries = {
                      AppendEntriesST.decode(_iprot)
                    }
                    _got_appendEntries = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          appendEntries
        )
      }
    }
  
    /**
     * The default read-only implementation of sendAppendEntries$args.  You typically should not need to
     * directly reference this class; instead, use the sendAppendEntries$args.apply method to construct
     * new instances.
     */
    class Immutable(
      val appendEntries: AppendEntriesST
    ) extends sendAppendEntries$args
  
  }
  
  trait sendAppendEntries$args extends ThriftStruct
    with Product1[AppendEntriesST]
    with java.io.Serializable
  {
    import sendAppendEntries$args._
  
  
    def appendEntries: AppendEntriesST
  
    def _1 = appendEntries
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): sendAppendEntries$args =
      _fieldId match {
        case 1 => copy(appendEntries = null)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      sendAppendEntries$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (appendEntries ne null) {
        val appendEntries_item = appendEntries
        _oprot.writeFieldBegin(AppendEntriesField)
        appendEntries_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      appendEntries: AppendEntriesST = this.appendEntries
    ): sendAppendEntries$args =
      new Immutable(
        appendEntries
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendAppendEntries$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => appendEntries
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendAppendEntries$args"
  }
  
  object sendAppendEntries$result extends ThriftStructCodec3[sendAppendEntries$result] {
    val Struct = new TStruct("sendAppendEntries_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[AppendEntriesResponseST]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendAppendEntries$result) {
    }
  
    override def encode(_item: sendAppendEntries$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): sendAppendEntries$result = Immutable.decode(_iprot)
  
    def apply(
      success: Option[AppendEntriesResponseST] = None
    ): sendAppendEntries$result = new Immutable(
      success
    )
  
    def unapply(_item: sendAppendEntries$result): Option[Option[AppendEntriesResponseST]] = Some(_item.success)
  
    object Immutable extends ThriftStructCodec3[sendAppendEntries$result] {
      override def encode(_item: sendAppendEntries$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): sendAppendEntries$result = {
        var success: AppendEntriesResponseST = null
        var _got_success = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      AppendEntriesResponseST.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of sendAppendEntries$result.  You typically should not need to
     * directly reference this class; instead, use the sendAppendEntries$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[AppendEntriesResponseST] = None
    ) extends sendAppendEntries$result
  
  }
  
  trait sendAppendEntries$result extends ThriftStruct
    with Product1[Option[AppendEntriesResponseST]]
    with java.io.Serializable
  {
    import sendAppendEntries$result._
  
  
    def success: Option[AppendEntriesResponseST]
  
    def _1 = success
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): sendAppendEntries$result =
      _fieldId match {
        case 0 => copy(success = None)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      sendAppendEntries$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[AppendEntriesResponseST] = this.success
    ): sendAppendEntries$result =
      new Immutable(
        success
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendAppendEntries$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendAppendEntries$result"
  }
  
  object forwardCommand$args extends ThriftStructCodec3[forwardCommand$args] {
    val Struct = new TStruct("forwardCommand_args")
    val CommandField = new TField("command", TType.STRING, 1)
    val CommandFieldManifest = implicitly[Manifest[ByteBuffer]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: forwardCommand$args) {
    }
  
    override def encode(_item: forwardCommand$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): forwardCommand$args = Immutable.decode(_iprot)
  
    def apply(
      command: ByteBuffer
    ): forwardCommand$args = new Immutable(
      command
    )
  
    def unapply(_item: forwardCommand$args): Option[ByteBuffer] = Some(_item.command)
  
    object Immutable extends ThriftStructCodec3[forwardCommand$args] {
      override def encode(_item: forwardCommand$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): forwardCommand$args = {
        var command: ByteBuffer = null
        var _got_command = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* command */
                _field.`type` match {
                  case TType.STRING => {
                    command = {
                      _iprot.readBinary()
                    }
                    _got_command = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          command
        )
      }
    }
  
    /**
     * The default read-only implementation of forwardCommand$args.  You typically should not need to
     * directly reference this class; instead, use the forwardCommand$args.apply method to construct
     * new instances.
     */
    class Immutable(
      val command: ByteBuffer
    ) extends forwardCommand$args
  
  }
  
  trait forwardCommand$args extends ThriftStruct
    with Product1[ByteBuffer]
    with java.io.Serializable
  {
    import forwardCommand$args._
  
  
    def command: ByteBuffer
  
    def _1 = command
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): forwardCommand$args =
      _fieldId match {
        case 1 => copy(command = null)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      forwardCommand$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (command ne null) {
        val command_item = command
        _oprot.writeFieldBegin(CommandField)
        _oprot.writeBinary(command_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      command: ByteBuffer = this.command
    ): forwardCommand$args =
      new Immutable(
        command
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[forwardCommand$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => command
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "forwardCommand$args"
  }
  
  object forwardCommand$result extends ThriftStructCodec3[forwardCommand$result] {
    val Struct = new TStruct("forwardCommand_result")
    val SuccessField = new TField("success", TType.STRING, 0)
    val SuccessFieldManifest = implicitly[Manifest[ByteBuffer]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: forwardCommand$result) {
    }
  
    override def encode(_item: forwardCommand$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): forwardCommand$result = Immutable.decode(_iprot)
  
    def apply(
      success: Option[ByteBuffer] = None
    ): forwardCommand$result = new Immutable(
      success
    )
  
    def unapply(_item: forwardCommand$result): Option[Option[ByteBuffer]] = Some(_item.success)
  
    object Immutable extends ThriftStructCodec3[forwardCommand$result] {
      override def encode(_item: forwardCommand$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): forwardCommand$result = {
        var success: ByteBuffer = null
        var _got_success = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRING => {
                    success = {
                      _iprot.readBinary()
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of forwardCommand$result.  You typically should not need to
     * directly reference this class; instead, use the forwardCommand$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[ByteBuffer] = None
    ) extends forwardCommand$result
  
  }
  
  trait forwardCommand$result extends ThriftStruct
    with Product1[Option[ByteBuffer]]
    with java.io.Serializable
  {
    import forwardCommand$result._
  
  
    def success: Option[ByteBuffer]
  
    def _1 = success
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): forwardCommand$result =
      _fieldId match {
        case 0 => copy(success = None)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      forwardCommand$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        _oprot.writeBinary(success_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[ByteBuffer] = this.success
    ): forwardCommand$result =
      new Immutable(
        success
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[forwardCommand$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "forwardCommand$result"
  }
  
  object installSnapshot$args extends ThriftStructCodec3[installSnapshot$args] {
    val Struct = new TStruct("installSnapshot_args")
    val InstallSnapshotField = new TField("installSnapshot", TType.STRUCT, 1)
    val InstallSnapshotFieldManifest = implicitly[Manifest[InstallSnapshotST]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: installSnapshot$args) {
    }
  
    override def encode(_item: installSnapshot$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): installSnapshot$args = Immutable.decode(_iprot)
  
    def apply(
      installSnapshot: InstallSnapshotST
    ): installSnapshot$args = new Immutable(
      installSnapshot
    )
  
    def unapply(_item: installSnapshot$args): Option[InstallSnapshotST] = Some(_item.installSnapshot)
  
    object Immutable extends ThriftStructCodec3[installSnapshot$args] {
      override def encode(_item: installSnapshot$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): installSnapshot$args = {
        var installSnapshot: InstallSnapshotST = null
        var _got_installSnapshot = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* installSnapshot */
                _field.`type` match {
                  case TType.STRUCT => {
                    installSnapshot = {
                      InstallSnapshotST.decode(_iprot)
                    }
                    _got_installSnapshot = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          installSnapshot
        )
      }
    }
  
    /**
     * The default read-only implementation of installSnapshot$args.  You typically should not need to
     * directly reference this class; instead, use the installSnapshot$args.apply method to construct
     * new instances.
     */
    class Immutable(
      val installSnapshot: InstallSnapshotST
    ) extends installSnapshot$args
  
  }
  
  trait installSnapshot$args extends ThriftStruct
    with Product1[InstallSnapshotST]
    with java.io.Serializable
  {
    import installSnapshot$args._
  
  
    def installSnapshot: InstallSnapshotST
  
    def _1 = installSnapshot
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): installSnapshot$args =
      _fieldId match {
        case 1 => copy(installSnapshot = null)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      installSnapshot$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (installSnapshot ne null) {
        val installSnapshot_item = installSnapshot
        _oprot.writeFieldBegin(InstallSnapshotField)
        installSnapshot_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      installSnapshot: InstallSnapshotST = this.installSnapshot
    ): installSnapshot$args =
      new Immutable(
        installSnapshot
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[installSnapshot$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => installSnapshot
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "installSnapshot$args"
  }
  
  object installSnapshot$result extends ThriftStructCodec3[installSnapshot$result] {
    val Struct = new TStruct("installSnapshot_result")
    val SuccessField = new TField("success", TType.BOOL, 0)
    val SuccessFieldManifest = implicitly[Manifest[Boolean]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: installSnapshot$result) {
    }
  
    override def encode(_item: installSnapshot$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): installSnapshot$result = Immutable.decode(_iprot)
  
    def apply(
      success: Option[Boolean] = None
    ): installSnapshot$result = new Immutable(
      success
    )
  
    def unapply(_item: installSnapshot$result): Option[Option[Boolean]] = Some(_item.success)
  
    object Immutable extends ThriftStructCodec3[installSnapshot$result] {
      override def encode(_item: installSnapshot$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): installSnapshot$result = {
        var success: Boolean = false
        var _got_success = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.BOOL => {
                    success = {
                      _iprot.readBool()
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of installSnapshot$result.  You typically should not need to
     * directly reference this class; instead, use the installSnapshot$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[Boolean] = None
    ) extends installSnapshot$result
  
  }
  
  trait installSnapshot$result extends ThriftStruct
    with Product1[Option[Boolean]]
    with java.io.Serializable
  {
    import installSnapshot$result._
  
  
    def success: Option[Boolean]
  
    def _1 = success
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): installSnapshot$result =
      _fieldId match {
        case 0 => copy(success = None)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      installSnapshot$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        _oprot.writeBool(success_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Boolean] = this.success
    ): installSnapshot$result =
      new Immutable(
        success
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[installSnapshot$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "installSnapshot$result"
  }
  
  object join$args extends ThriftStructCodec3[join$args] {
    val Struct = new TStruct("join_args")
    val MemberIdField = new TField("memberId", TType.STRUCT, 1)
    val MemberIdFieldManifest = implicitly[Manifest[JoinRequestST]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: join$args) {
    }
  
    override def encode(_item: join$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): join$args = Immutable.decode(_iprot)
  
    def apply(
      memberId: JoinRequestST
    ): join$args = new Immutable(
      memberId
    )
  
    def unapply(_item: join$args): Option[JoinRequestST] = Some(_item.memberId)
  
    object Immutable extends ThriftStructCodec3[join$args] {
      override def encode(_item: join$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): join$args = {
        var memberId: JoinRequestST = null
        var _got_memberId = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 => { /* memberId */
                _field.`type` match {
                  case TType.STRUCT => {
                    memberId = {
                      JoinRequestST.decode(_iprot)
                    }
                    _got_memberId = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          memberId
        )
      }
    }
  
    /**
     * The default read-only implementation of join$args.  You typically should not need to
     * directly reference this class; instead, use the join$args.apply method to construct
     * new instances.
     */
    class Immutable(
      val memberId: JoinRequestST
    ) extends join$args
  
  }
  
  trait join$args extends ThriftStruct
    with Product1[JoinRequestST]
    with java.io.Serializable
  {
    import join$args._
  
  
    def memberId: JoinRequestST
  
    def _1 = memberId
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): join$args =
      _fieldId match {
        case 1 => copy(memberId = null)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      join$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (memberId ne null) {
        val memberId_item = memberId
        _oprot.writeFieldBegin(MemberIdField)
        memberId_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      memberId: JoinRequestST = this.memberId
    ): join$args =
      new Immutable(
        memberId
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[join$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => memberId
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "join$args"
  }
  
  object join$result extends ThriftStructCodec3[join$result] {
    val Struct = new TStruct("join_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[JoinResponseST]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: join$result) {
    }
  
    override def encode(_item: join$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): join$result = Immutable.decode(_iprot)
  
    def apply(
      success: Option[JoinResponseST] = None
    ): join$result = new Immutable(
      success
    )
  
    def unapply(_item: join$result): Option[Option[JoinResponseST]] = Some(_item.success)
  
    object Immutable extends ThriftStructCodec3[join$result] {
      override def encode(_item: join$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): join$result = {
        var success: JoinResponseST = null
        var _got_success = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      JoinResponseST.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of join$result.  You typically should not need to
     * directly reference this class; instead, use the join$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[JoinResponseST] = None
    ) extends join$result
  
  }
  
  trait join$result extends ThriftStruct
    with Product1[Option[JoinResponseST]]
    with java.io.Serializable
  {
    import join$result._
  
  
    def success: Option[JoinResponseST]
  
    def _1 = success
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): join$result =
      _fieldId match {
        case 0 => copy(success = None)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      join$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[JoinResponseST] = this.success
    ): join$result =
      new Immutable(
        success
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[join$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "join$result"
  }
  
  object getMembers$args extends ThriftStructCodec3[getMembers$args] {
    val Struct = new TStruct("getMembers_args")
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: getMembers$args) {
    }
  
    override def encode(_item: getMembers$args, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): getMembers$args = Immutable.decode(_iprot)
  
    def apply(
    ): getMembers$args = new Immutable(
    )
  
    def unapply(_item: getMembers$args): Boolean = true
  
    object Immutable extends ThriftStructCodec3[getMembers$args] {
      override def encode(_item: getMembers$args, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): getMembers$args = {
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
        )
      }
    }
  
    /**
     * The default read-only implementation of getMembers$args.  You typically should not need to
     * directly reference this class; instead, use the getMembers$args.apply method to construct
     * new instances.
     */
    class Immutable(
    ) extends getMembers$args
  
  }
  
  trait getMembers$args extends ThriftStruct
    with Product
    with java.io.Serializable
  {
    import getMembers$args._
  
  
  
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): getMembers$args =
      _fieldId match {
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      getMembers$args.validate(this)
      _oprot.writeStructBegin(Struct)
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
    ): getMembers$args =
      new Immutable(
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[getMembers$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "getMembers$args"
  }
  
  object getMembers$result extends ThriftStructCodec3[getMembers$result] {
    val Struct = new TStruct("getMembers_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[GetMembersResponseST]]
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: getMembers$result) {
    }
  
    override def encode(_item: getMembers$result, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): getMembers$result = Immutable.decode(_iprot)
  
    def apply(
      success: Option[GetMembersResponseST] = None
    ): getMembers$result = new Immutable(
      success
    )
  
    def unapply(_item: getMembers$result): Option[Option[GetMembersResponseST]] = Some(_item.success)
  
    object Immutable extends ThriftStructCodec3[getMembers$result] {
      override def encode(_item: getMembers$result, _oproto: TProtocol) { _item.write(_oproto) }
      override def decode(_iprot: TProtocol): getMembers$result = {
        var success: GetMembersResponseST = null
        var _got_success = false
        var _done = false
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 => { /* success */
                _field.`type` match {
                  case TType.STRUCT => {
                    success = {
                      GetMembersResponseST.decode(_iprot)
                    }
                    _got_success = true
                  }
                  case _ => TProtocolUtil.skip(_iprot, _field.`type`)
                }
              }
              case _ =>
                TProtocolUtil.skip(_iprot, _field.`type`)
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
        new Immutable(
          if (_got_success) Some(success) else None
        )
      }
    }
  
    /**
     * The default read-only implementation of getMembers$result.  You typically should not need to
     * directly reference this class; instead, use the getMembers$result.apply method to construct
     * new instances.
     */
    class Immutable(
      val success: Option[GetMembersResponseST] = None
    ) extends getMembers$result
  
  }
  
  trait getMembers$result extends ThriftStruct
    with Product1[Option[GetMembersResponseST]]
    with java.io.Serializable
  {
    import getMembers$result._
  
  
    def success: Option[GetMembersResponseST]
  
    def _1 = success
  
  
    /**
     * If the specified field is optional, it is set to None.  Otherwise, if the field is
     * known, it is reverted to its default value; if the field is unknown, it is subtracked
     * from the passthroughFields map, if present.
     */
    def unsetField(_fieldId: Short): getMembers$result =
      _fieldId match {
        case 0 => copy(success = None)
        case _ => this
      }
  
    override def write(_oprot: TProtocol) {
      getMembers$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) {
        val success_item = success.get
        _oprot.writeFieldBegin(SuccessField)
        success_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[GetMembersResponseST] = this.success
    ): getMembers$result =
      new Immutable(
        success
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[getMembers$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other)
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "getMembers$result"
  }

  import com.twitter.util.Future

  @deprecated("use CKiteService[Future]", "3.4.0")
  trait FutureIface extends  CKiteService[Future] {
    
    def sendRequestVote(requestVote: RequestVoteST): Future[RequestVoteResponseST]
    
    def sendAppendEntries(appendEntries: AppendEntriesST): Future[AppendEntriesResponseST]
    
    def forwardCommand(command: ByteBuffer): Future[ByteBuffer]
    
    def installSnapshot(installSnapshot: InstallSnapshotST): Future[Boolean]
    
    def join(memberId: JoinRequestST): Future[JoinResponseST]
    
    def getMembers(): Future[GetMembersResponseST]
  }

  @deprecated("use CKiteService$FinagleClient", "3.4.0")
  class FinagledClient(
      service: com.twitter.finagle.Service[com.twitter.finagle.thrift.ThriftClientRequest, Array[Byte]],
      protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
      serviceName: String = "",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver)
    extends CKiteService$FinagleClient(
      service,
      protocolFactory,
      serviceName,
      stats)
    with FutureIface

  @deprecated("use CKiteService$FinagleService", "3.4.0")
  class FinagledService(
      iface: FutureIface,
      protocolFactory: TProtocolFactory)
    extends CKiteService$FinagleService(
      iface,
      protocolFactory)
}